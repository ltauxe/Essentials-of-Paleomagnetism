	program bootstrap	dimension x(1000),b(10000)	character*20 arg	nmax=1000	xsum=0	idum=-22	call getarg(1,arg)	if(arg.ne."-b")then	 write(*,*)'usage: bootstrap -b [nb] > [output]'	 stop	endif	call getarg(2,arg)	read(arg,*)nb	do 100 i=1,nmax	read(*,*,end=200)x(i)	xsum=xsum+x(i) 100	continue 200	n=i-1		xbar=xsum/float(n)cc	now do bootstrapc	do 400 k=1,nb	xsum=0	do 300 i=1,n	r=ran1(idum)		j=r*(float(n-1))+1	xsum=xsum+x(j) 300	continue	b(k)=xsum/float(n) 400	continue	call sortg2(b,nb)	call histplot(b,nb)	end	subroutine histplot(d,n)c	writes a plotxy file for the histogram of dc	dimension d(1000),h(2,300) 	xmax=-1e12 	xmin=1e11 	xsum=0 	do 40 i=1,300 	h(1,i)=0 	h(2,i)=0 40	continue	do 100 i=1,n      	if(d(i).gt.xmax) then	xmax=d(i)	endif	if(d(i).lt.xmin) then	xmin=d(i)	endif  100	continue	xincr=(4*abs(xmin-xmax))/100 200	write(*,*)'frame'	write(*,*)'file *'	write(*,*)'char .1'	write(*,*)'xlim 2.75 ',xmin-xincr,xmax+xincr	write(*,*)'ylim 2.75 '	write(*,*)'xlab x'	write(*,*)'ylab Fraction '   	bin0=xmin 	bin1=bin0+xincr 	ibin=1 275	do 300 i=1,n	x=d(i)	h(1,ibin)=bin0 	if(x.ge.bin0) then 	if(x.lt.bin1) then 	h(2,ibin)=h(2,ibin)+1 	endif 	endif 300	continue 	if(bin0.gt.xmax) then 	goto 500 	endif 	bin0=bin0+xincr 	bin1=bin1+xincr 	ibin=ibin+1 	goto 275 500	write(*,*)'read ',2*ibin+3  	write(*,*)h(1,1),0	do 22 i=1,ibin  	write(*,*)h(1,i),h(2,i)/float(n) 22 	write(*,*)h(1,i)+xincr,h(2,i)/float(n)	write(*,*)h(1,i)+xincr,0  	write(*,*)h(1,1),0	low=.025*n	ihi=.975*n	write(*,'(a,f6.2,a,f6.2)')'title 95% Bootstrap Interval:', d(low),' - ',d(ihi)	write(*,*)'plot 2 4'	write(*,*)'stop'   	end       FUNCTION RAN1(IDUM)      DIMENSION R(97)      PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)      PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)      PARAMETER (M3=243000,IA3=4561,IC3=51349)      DATA IFF /0/      IF (IDUM.LT.0.OR.IFF.EQ.0) THEN        IFF=1        IX1=MOD(IC1-IDUM,M1)        IX1=MOD(IA1*IX1+IC1,M1)        IX2=MOD(IX1,M2)        IX1=MOD(IA1*IX1+IC1,M1)        IX3=MOD(IX1,M3)        DO 11 J=1,97          IX1=MOD(IA1*IX1+IC1,M1)          IX2=MOD(IA2*IX2+IC2,M2)          R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM111      CONTINUE        IDUM=1      ENDIF      IX1=MOD(IA1*IX1+IC1,M1)      IX2=MOD(IA2*IX2+IC2,M2)      IX3=MOD(IA3*IX3+IC3,M3)      J=1+(97*IX3)/M3      IF(J.GT.97.OR.J.LT.1)PAUSE      RAN1=R(J)      R(J)=(FLOAT(IX1)+FLOAT(IX2)*RM2)*RM1      RETURN      END      subroutine sortg2(a, n)cc ** modification of sortg by SCC july 1987 to remove tag array**cc to sort n elements starting with a(k), call with a(k) and tag(k).c an earlier version of this algorithm, without the tag array, wasc published by r.c. singleton as acm algorithm 347,c comm. acm 12 (march 1969), 1865-1866.  the current versionc solves a machine-dependent problem present in the earlierc version and almost all other sort subroutines.  on manyc computers, comparing a very large negative number with ac very large positive number gives a wrong result and a bad sort.c this problem was noted by r. griffin and k.a. redish, "remarkc on algorithm 347,", comm. acm 13 (january 1970), 54.c the problem is avoided here by an initial split on zero.c time is proportional to n*log(n)c as far as the author is aware, no faster in-place sort method hasc been published since the original appearance of this algorithm.cc working storage arrays il and iu should have dimensionc      int(alog(float(n))/alog(2.0))c      a dimension of 20 allows values of n up to 2**21-1c      dimension a(1), iu(20), il(20)      m = 1      i = 1      j = n      k = i      l = j      if (i.ge.j) return      t = 0      if (a(i)) 30, 30, 10  10  if (a(l)) 90, 90, 20  20  l = l - 1      if (l-i) 70, 70, 10  30  if (a(j)) 40, 110, 110  40  if (a(k)) 50, 90, 90  50  k = k + 1      if (j-k) 70, 70, 40  60  if (i.ge.j) go to 140  70  k = i      ij = (j+i)/2      t = a(ij)      if (a(i).le.t) go to 80      a(ij) = a(i)      a(i) = t      t = a(ij)  80  l = j      if (a(j).ge.t) go to 110      a(ij) = a(j)      a(j) = t      t = a(ij)      if (a(i).le.t) go to 110      a(ij) = a(i)      a(i) = t      t = a(ij)      go to 110  90  tt = a(l) 100  a(l) = a(k)      a(k) = tt 110  l = l - 1      if (a(l).gt.t) go to 110      tt = a(l) 120  k = k + 1      if (a(k).lt.t) go to 120      if (k.le.l) go to 100      if (l-i.le.j-k) go to 130      il(m) = i      iu(m) = l      i = k      m = m + 1      go to 150 130  il(m) = k      iu(m) = j      j = l      m = m + 1      go to 150 140  m = m - 1      if (m.eq.0) return      i = il(m)      j = iu(m) 150  if (j-i.gt.10) go to 70      if (i.eq.1) go to 60      i = i - 1 160  i = i + 1      if (i.eq.j) go to 140      t = a(i+1)      if (a(i).le.t) go to 160      k = i 170  a(k+1) = a(k)      k = k - 1      if (t.lt.a(k)) go to 170      a(k+1) = t      go to 160      end